-- optional entrypoint
entrypoints Program ;

-- Programs
Prog. Program  ::= [Def] ;
terminator Def "" ;

-- Comments are ignored
comment "//" ;
comment "#" ;
comment "/*" "*/" ;

-- Definitions
DProto. Def ::= Type Id "(" [Arg] ")" ";" ; --function prototype grammar.cc 48
DFunc. Def ::= Type Id "(" [Arg] ")" "{" [Stm] "}" ;
-- alt Body => BStm . Body ::= "{" [Stm] "}" ;
DTypedefdef. Def ::= TyDef ";";  --The problem with grammar.cc is that it has typedefs outside of any function, they become statements but not defs.
--this solution looks kinda ugly, but allows a single definition of the typedef statement to be used outside of functions as defs, and also inside functions as statements (below).  I moved the definition of typedef outside, and then allowed it to be a statement or a def, adding ";" for the def
DTypedef. TyDef ::= "typedef" QConst Id ;
--DTypedef. Def ::= "typedef" QConst Id ;
--VarDecl
--DStruct
DUsing. Def ::= "using" QConst ";" ;


-- Varible and argument declarations -- watch out for counterexample!
ConstArg. Arg ::= "const" Arg;
DecArg. Arg ::= Type Id ;
DecArgNoname. Arg ::= Type; --Arguments in function prototypes don't have to have names (grammar.cc line 48)
DecArgRef. Arg ::= Type "&" Id; -- probably want to make & part of Id, not of Type, to be correct and general in cases such as  int &a, b, &c  or int *a , b, *c , Watch out for counterexmaples!

DefArgRefNoname. Arg ::= Type "&" ; -- grammar 48, prototype with & noname args. getting too specific, I know

separator Arg "," ;
DecVar. Var ::= Type [Id] ;
separator nonempty  Id "," ;

-- statements
SExpr.    Stm ::= Exp ";" ;
SVar.     Stm ::= Var ";" ;
SRet.     Stm ::= "return" Exp ";" ;
SDecl.    Stm ::= Type Id ;
SBlock.   Stm ::= "{" [Stm] "}" ;
SWhile.   Stm ::= "while" "(" Exp ")" Stm ;
STDef.    Stm ::= TyDef;
--STDef.    Stm ::= "typedef" QConst Id;
SIfpart.  IfHead ::= "if" "(" Exp ")" Stm ; --more compact
SIfElse.  Stm ::= IfHead "else" Stm ; --book  34, grammar.cc 68-70 -adds else option
SIf.      Stm ::= IfHead; -- if without else
--terminator Function ""  ;
terminator Stm	    "" ;



-- expressions
EInt.    Exp16 ::= Integer ;
EDbl.    Exp16 ::= Double ;
EChar.   Exp16 ::= Char ; --book 31 built in BNFC type, solves grammar.cc 61 '<'
--EString. Exp16 ::= String ;
EStrLit. Exp16 ::= [String] ;
EConst.  Exp15 ::= QConst ;
--EIndex.   Exp15 ::= Exp16 "[" Exp "]" ;
EIndex. Exp15 ::= Id "[" Exp "]" ;
EFunCall. Exp15 ::= Id "("[Exp]")" ;
EStrDot. Exp14 ::= Exp15"."Exp15 ;
EStrArr. Exp14 ::= Exp15"->"Exp15 ;
--Exp14 e++, e--, *e 
--Exp13 ++e, --e, !e
--Exp12 *,/,%

EMul.    Exp12 ::= Exp12 "*" Exp13 ;  --from book p35
EAdd.    Exp11 ::= Exp11 "+" Exp12 ;
ESub.    Exp11 ::= Exp11 "-" Exp12 ;
EDiv.    Exp12 ::= Exp13 "/" Exp13 ;
EMod.    Exp12 ::= Exp13 "%" Exp13 ;
--Exp11 +,-
ELShift.  Exp10 ::= Exp10 "<<" Exp11 ; --left-associativity
ERShift.  Exp10 ::= Exp11 ">>" Exp10 ;
EGt.      Exp9  ::= Exp9 ">" Exp10; --book 35  grammar.cc 61
--EComp.  Exp9
EEqual.   Exp8  ::= Exp9 "==" Exp9 ;
EIneq.    Exp8  ::= Exp9 "!=" Exp9 ;
EAnd.     Exp4  ::= Exp4 "&&" Exp5 ; -- book p36,  grammar.cc 61
EAssign.  Exp2  ::= Exp3 "=" Exp2 ;
ETernary. Exp2  ::= Exp3 "?" Exp3 ":" Exp3 ;
ENegate.  Exp1  ::= "!" Exp2; --I put this lowest, figure it can negate any higher level exp -- grammar.cc line 40
separator Exp "," ;
separator String "" ;

coercions Exp 16 ;

--qualified constants
QCon.  QConst ::= [Const] ;
separator nonempty Const "::" ;

CTempl. Const ::= Id"<"[Type]">" ;
CId.    Const ::= Id ;
separator nonempty Type "," ;

--TT.     TType ::= Type ;
--types
TInt.   Type  ::= "int" ;
TDoube. Type  ::= "double" ;
TConst. Type  ::= QConst ;

--names : Ident allows \', we should not!
token Id (letter (letter | digit | '_')*) ;



--SReturn. Stm ::= "return" Ident ;
--SReturn2. Stm ::= "return" Integer ;
--SExpr. Stm ::= "" ; 

--MClassMethod. Mth ::= Ident "::" Ident ;

--S1.   Stm  ::= Ident ;
--S2.   Stm  ::= Mth ;
--S3.   Stm  ::= Mth "<<" String "<<" Mth ;
--TInt. Type ::= "int" ;




