-- optional entrypoint
entrypoints Program ;

-- Programs
Prog. Program  ::= [Def] ;
terminator Def "" ;


-- Defnitions
DFun.        Def ::= Fun ;
DTDef.       Def ::= TDef ";" ;
DVar.        Def ::= Var ";" ;
DStruct.     Def ::= Str ";" ;
DUsing.      Def ::= "using" QConst ";" ;

-- Functions
FProto.  Fun ::= Type Id "(" [Arg] ")" ";" ; -- function prototype grammar.cc 48
FDef.    Fun ::= Type Id "(" [Arg] ")" "{" [Stm] "}" ; -- function definition
Finline. Fun ::= "inline" Fun ;
--DFunBody. Body ::= "{" [Stm] "}" ;


--DTypedefdef. Def ::= TyDef ";" ;
-- The problem with grammar.cc is that it has typedefs outside of any function,
-- they become statements but not defs.
-- this solution looks kinda ugly, but allows a single definition of the typedef statement to be used outside of functions as defs, and also inside functions as statements (below).  I moved the definition of typedef outside, and then allowed it to be a statement or a def, adding ";" for the def

-- Typedefs and structs
-- 2 separate categories both as top-level definitions and statements
Typedef.    TDef ::= "typedef" QConst Id ;
Struct.     Str  ::= "struct" Id "{" [Dec] "}" ; -- with [Dec] inside curly brackets grammar won`t compile 
terminator Dec ";" ;

-- Generic declarations, used both for arguments and variables
DecSingle.     Dec ::= Type Id ;
DecConst.      Dec ::= "const" Type Id ;
DecInit.       Dec ::= Type Id "=" Exp ;
DecInitConst.  Dec ::= "const" Type Id "=" Exp ;



-- Function arguments
ADec.         Arg ::= Dec ;
   -- special cases - arguments only
ANoname.      Arg ::= Type ;
ANonameConst. Arg ::= "const" Type ;

separator Arg "," ;


--AConst.     Arg ::= "const" Dec;
--AConst.     Arg ::= "const" Type ;


--AInit.      Arg ::= Arg "=" Exp ;
--ADecl.      Arg ::= Init;

  -- special case declarations



   -- arguments in function prototypes do not have to have names (grammar.cc line 48)

--ARef. Arg ::= Type "&" Id; 
  -- probably want to make & part of Id, not of Type, to be correct and general in cases
  -- such as  int &a, b, &c  or int *a , b, *c , Watch out for counterexmaples!

--ARefNoname. Arg ::= Type "&" ;
  -- grammar 48, prototype with & noname args. getting too specific, I know



-- Variable declaration
VDec.   Var ::= Dec ;
--VConst. Var ::= "const" Dec ;
VMult.  Var ::= Type [Id] ;
--VInit. Var ::= Var "=" Exp ;

separator nonempty  Id "," ;

-- Statements
SExpr.      Stm ::= Exp ";" ;
SVar.       Stm ::= Var ";" ;
SRet.       Stm ::= "return" Exp ";" ;
SBlock.     Stm ::= "{" [Stm] "}" ;
SWhile.     Stm ::= "while" "(" Exp ")" Stm ;
SDoWhile.   Stm ::= "do" Stm "while" "(" Exp ")" ";" ;
SFor.       Stm ::= "for" "(" Var ";" Exp ";" Exp ")" Stm ;
STDef.      Stm ::= TDef ";" ;
SStruct.    Stm ::= Str ";" ;
--STDef.    Stm ::= "typedef" QConst Id;
SIfElse.    Stm ::= IfHead "else" Stm ; --book  34, grammar.cc 68-70 -adds else option
SIf.        Stm ::= IfHead; -- if without else
-- special category to deal with `dangling` else
SIfHead.    IfHead ::= "if" "(" Exp ")" Stm ; -- more compact
--terminator Function ""  ;

terminator Stm	    "" ;
--terminator Stm ";" ;


-- Expressions
EParenth.   Exp   ::= "(" Exp ")" ; -- general parenthesis rule
EInt.       Exp16 ::= Integer ;
EDbl.       Exp16 ::= Double ;
EChar.      Exp16 ::= Char ; --book 31 built in BNFC type, solves grammar.cc 61 '<'
--EString.  Exp16 ::= String ;
EStrLit.    Exp16 ::= [String] ;
EConst.     Exp15 ::= QConst ;
--EIndex.   Exp15 ::= Exp16 "[" Exp "]" ;
EIndex.     Exp15 ::= Id "[" Exp "]" ;
EFunCall.   Exp15 ::= Id "("[Exp]")" ;
EStrDot.    Exp14 ::= Exp15"."Exp15 ;
EStrArr.    Exp14 ::= Exp15"->"Exp15 ;
--Exp14 e++, e--, *e
EPostInc.   Exp14 ::= Exp15 "++" ;
EDeref.     Exp14 ::= "*" Exp15 ;
--Exp13 ++e, --e, !e
EPreInc.    Exp13 ::= "++" Exp14 ;

--Exp12 *,/,%

ENegate.    Exp13  ::= "!" Exp12;
  -- I put this lowest, figure it can negate any higher level exp -- grammar.cc line 40
  -- contradicts the spec
  -- arithmetic
EMul.       Exp12 ::= Exp12 "*"  Exp13 ;  --from book p35
EAdd.       Exp11 ::= Exp11 "+"  Exp12 ;
ESub.       Exp11 ::= Exp11 "-"  Exp12 ;
EDiv.       Exp12 ::= Exp13 "/"  Exp13 ;
EMod.       Exp12 ::= Exp13 "%"  Exp13 ;
  -- bitwise
ELShift.    Exp10 ::= Exp10 "<<" Exp11 ; --left-associativity
ERShift.    Exp10 ::= Exp11 ">>" Exp10 ;
  -- comparison
ELt.        Exp9  ::= Exp9  "<"  Exp10 ;
EGt.        Exp9  ::= Exp9  ">"  Exp10 ; --book 35  grammar.cc 61
ELtEq.      Exp9  ::= Exp9  "<=" Exp10 ;
EGtEq.      Exp9  ::= Exp9  ">=" Exp10 ;
EEqual.     Exp8  ::= Exp9  "==" Exp9 ;
EIneq.      Exp8  ::= Exp9  "!=" Exp9 ;
  -- logical
EAnd.       Exp4  ::= Exp4  "&&" Exp5 ; -- book p36,  grammar.cc 61
EOr.        Exp3  ::= Exp3  "||" Exp5 ;
  -- assignment
EAssign.    Exp2  ::= Exp3  "="  Exp2 ;
EAssignInc. Exp2  ::= Exp3  "+=" Exp2 ;
EAssignDec. Exp2  ::= Exp3  "-=" Exp2 ;

ETernary.   Exp2  ::= Exp3  "?"  Exp3 ":" Exp3 ;
EThrtow.    Exp1  ::= "throw" Exp2 ; 

separator Exp "," ;
separator nonempty String "" ;

coercions Exp 16 ;

--qualified constants
QCon.  QConst ::= [Const] ;
separator nonempty Const "::" ;

CTempl. Const ::= Id"<"[Type]">" ;
CId.    Const ::= Id ;
separator nonempty Type "," ;


-- Types
TVoid.  Type  ::= "void" ;
TBool.  Type  ::= "bool" ;
TInt.   Type  ::= "int" ;
TDoube. Type  ::= "double" ;
TConst. Type  ::= QConst ;
TRef.   Type  ::= Type "&" ; -- reference types


token Id (letter (letter | digit | '_')*) ;


-- Comments are ignored
comment "//" ;
comment "#" ;
comment "/*" "*/" ;

